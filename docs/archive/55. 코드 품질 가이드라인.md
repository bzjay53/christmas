# Christmas Trading ì½”ë“œ í’ˆì§ˆ ê°€ì´ë“œë¼ì¸

## ğŸ“‹ ë¬¸ì„œ ê°œìš”
ì´ ë¬¸ì„œëŠ” Christmas Trading í”„ë¡œì íŠ¸ì˜ ì½”ë“œ í’ˆì§ˆ í‘œì¤€, ì½”ë”© ì»¨ë²¤ì…˜, ëª¨ë²” ì‚¬ë¡€ë¥¼ ì •ì˜í•˜ì—¬ ì¼ê´€ì„± ìˆê³  ìœ ì§€ë³´ìˆ˜ ê°€ëŠ¥í•œ ì½”ë“œë² ì´ìŠ¤ë¥¼ êµ¬ì¶•í•˜ê¸° ìœ„í•œ ê°€ì´ë“œë¼ì¸ì…ë‹ˆë‹¤.

## ğŸ¯ ì½”ë“œ í’ˆì§ˆ ëª©í‘œ

### ğŸ” í•µì‹¬ ì›ì¹™
1. **ê°€ë…ì„±**: ì½”ë“œëŠ” ë¬¸ì„œì²˜ëŸ¼ ì½í˜€ì•¼ í•¨
2. **ì¼ê´€ì„±**: í”„ë¡œì íŠ¸ ì „ì²´ì—ì„œ ë™ì¼í•œ ìŠ¤íƒ€ì¼ ìœ ì§€
3. **ë‹¨ìˆœì„±**: ë³µì¡ì„±ì„ ìµœì†Œí™”í•˜ê³  ëª…í™•í•œ êµ¬ì¡° ìœ ì§€
4. **ì¬ì‚¬ìš©ì„±**: ëª¨ë“ˆí™”ëœ ì»´í¬ë„ŒíŠ¸ì™€ í•¨ìˆ˜ ì‘ì„±
5. **í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±**: í…ŒìŠ¤íŠ¸í•˜ê¸° ì‰¬ìš´ êµ¬ì¡°ë¡œ ì„¤ê³„

### ğŸ“Š í’ˆì§ˆ ë©”íŠ¸ë¦­
- **ì½”ë“œ ë³µì¡ë„**: Cyclomatic Complexity â‰¤ 10
- **í•¨ìˆ˜ ê¸¸ì´**: â‰¤ 50ì¤„
- **íŒŒì¼ í¬ê¸°**: â‰¤ 500ì¤„
- **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: â‰¥ 80%
- **ì¤‘ë³µ ì½”ë“œ**: â‰¤ 3%

## ğŸ¨ ì½”ë”© ìŠ¤íƒ€ì¼ ê°€ì´ë“œ

### ğŸ“ JavaScript/TypeScript

#### 1. ë„¤ì´ë° ì»¨ë²¤ì…˜
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ
const userAccountBalance = 1000000
const isUserAuthenticated = true
const getUserProfile = async (userId) => { /* ... */ }

class KISApiClient {
  constructor(appKey, appSecret) {
    this.appKey = appKey
    this.appSecret = appSecret
  }
  
  async getAccessToken() { /* ... */ }
}

// âŒ ë‚˜ìœ ì˜ˆì‹œ
const bal = 1000000
const auth = true
const getUsrProf = async (id) => { /* ... */ }

class kisapi {
  constructor(k, s) {
    this.k = k
    this.s = s
  }
}
```

#### 2. í•¨ìˆ˜ ì‘ì„± ì›ì¹™
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ë‹¨ì¼ ì±…ì„ ì›ì¹™
const calculatePortfolioValue = (holdings) => {
  return holdings.reduce((total, holding) => {
    return total + (holding.quantity * holding.currentPrice)
  }, 0)
}

const formatCurrency = (amount, currency = 'KRW') => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: currency
  }).format(amount)
}

// âŒ ë‚˜ìœ ì˜ˆì‹œ - ì—¬ëŸ¬ ì±…ì„ì„ ê°€ì§„ í•¨ìˆ˜
const processUserData = (user) => {
  // í¬íŠ¸í´ë¦¬ì˜¤ ê³„ì‚°
  const portfolioValue = user.holdings.reduce((total, holding) => {
    return total + (holding.quantity * holding.currentPrice)
  }, 0)
  
  // í†µí™” í¬ë§·íŒ…
  const formattedValue = new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW'
  }).format(portfolioValue)
  
  // ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
  updateUserInDatabase(user.id, { portfolioValue: formattedValue })
  
  // ì•Œë¦¼ ì „ì†¡
  sendNotificationToUser(user.id, `í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜: ${formattedValue}`)
  
  return formattedValue
}
```

#### 3. ì—ëŸ¬ ì²˜ë¦¬
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ëª…ì‹œì  ì—ëŸ¬ ì²˜ë¦¬
const fetchStockPrice = async (symbol) => {
  try {
    const response = await apiService.get(`/api/stocks/${symbol}/price`)
    
    if (!response.success) {
      throw new Error(`ì£¼ì‹ ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨: ${response.message}`)
    }
    
    return response.data
  } catch (error) {
    console.error(`ì£¼ì‹ ê°€ê²© ì¡°íšŒ ì˜¤ë¥˜ (${symbol}):`, error)
    throw new Error(`${symbol} ì£¼ì‹ ê°€ê²©ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)
  }
}

// âŒ ë‚˜ìœ ì˜ˆì‹œ - ì—ëŸ¬ ë¬´ì‹œ
const fetchStockPrice = async (symbol) => {
  try {
    const response = await apiService.get(`/api/stocks/${symbol}/price`)
    return response.data
  } catch (error) {
    return null // ì—ëŸ¬ ì •ë³´ ì†ì‹¤
  }
}
```

### âš›ï¸ React ì»´í¬ë„ŒíŠ¸

#### 1. ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°
```jsx
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ëª…í™•í•œ êµ¬ì¡°
import React, { useState, useEffect, useCallback } from 'react'
import PropTypes from 'prop-types'
import { Box, Typography, Button } from '@mui/material'
import { useNotification } from '../hooks/useNotification'
import apiService from '../lib/apiService'

/**
 * ì£¼ì‹ ê°€ê²© í‘œì‹œ ì»´í¬ë„ŒíŠ¸
 * @param {string} symbol - ì£¼ì‹ ì‹¬ë³¼ (ì˜ˆ: '005930')
 * @param {function} onPriceUpdate - ê°€ê²© ì—…ë°ì´íŠ¸ ì½œë°±
 */
const StockPrice = ({ symbol, onPriceUpdate }) => {
  const [price, setPrice] = useState(null)
  const [loading, setLoading] = useState(false)
  const { showNotification } = useNotification()
  
  const fetchPrice = useCallback(async () => {
    setLoading(true)
    try {
      const priceData = await apiService.getStockPrice(symbol)
      setPrice(priceData)
      onPriceUpdate?.(symbol, priceData)
    } catch (error) {
      showNotification(`ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`, 'error')
    } finally {
      setLoading(false)
    }
  }, [symbol, onPriceUpdate, showNotification])
  
  useEffect(() => {
    fetchPrice()
  }, [fetchPrice])
  
  if (loading) {
    return <Typography>ë¡œë”© ì¤‘...</Typography>
  }
  
  return (
    <Box sx={{ p: 2, border: 1, borderColor: 'grey.300', borderRadius: 1 }}>
      <Typography variant="h6">{symbol}</Typography>
      <Typography variant="h4" color="primary">
        {price ? `${price.toLocaleString()}ì›` : 'ê°€ê²© ì •ë³´ ì—†ìŒ'}
      </Typography>
      <Button onClick={fetchPrice} size="small">
        ìƒˆë¡œê³ ì¹¨
      </Button>
    </Box>
  )
}

StockPrice.propTypes = {
  symbol: PropTypes.string.isRequired,
  onPriceUpdate: PropTypes.func
}

export default StockPrice
```

#### 2. ì»¤ìŠ¤í…€ í›…
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í›…
import { useState, useEffect, useCallback } from 'react'
import apiService from '../lib/apiService'

/**
 * KIS API ì„¤ì • ê´€ë¦¬ í›…
 */
export const useKISApi = () => {
  const [settings, setSettings] = useState({
    mockMode: true,
    demoAppKey: '',
    demoAppSecret: '',
    realAppKey: '',
    realAppSecret: '',
    accountNumber: ''
  })
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  
  const loadSettings = useCallback(async () => {
    setLoading(true)
    setError(null)
    
    try {
      const savedSettings = localStorage.getItem('kisApiSettings')
      if (savedSettings) {
        setSettings(prev => ({ ...prev, ...JSON.parse(savedSettings) }))
      }
      
      const response = await apiService.loadKisSettings()
      if (response.success) {
        setSettings(prev => ({ ...prev, ...response.data }))
      }
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [])
  
  const saveSettings = useCallback(async (newSettings) => {
    setLoading(true)
    setError(null)
    
    try {
      localStorage.setItem('kisApiSettings', JSON.stringify(newSettings))
      const response = await apiService.saveKisSettings(newSettings)
      
      if (response.success) {
        setSettings(newSettings)
        return true
      } else {
        throw new Error(response.message)
      }
    } catch (err) {
      setError(err.message)
      return false
    } finally {
      setLoading(false)
    }
  }, [])
  
  const testConnection = useCallback(async () => {
    try {
      const response = await apiService.getKisStatus()
      return response.success
    } catch (err) {
      setError(err.message)
      return false
    }
  }, [])
  
  useEffect(() => {
    loadSettings()
  }, [loadSettings])
  
  return {
    settings,
    loading,
    error,
    saveSettings,
    testConnection,
    updateSettings: setSettings
  }
}
```

### ğŸ”§ Node.js ë°±ì—”ë“œ

#### 1. ë¼ìš°í„° êµ¬ì¡°
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ëª¨ë“ˆí™”ëœ ë¼ìš°í„°
// routes/kis/index.js
const express = require('express')
const router = express.Router()
const kisController = require('../../controllers/kisController')
const { validateKisCredentials } = require('../../middleware/validation')
const { authenticate } = require('../../middleware/auth')

/**
 * KIS API ìƒíƒœ ì¡°íšŒ
 * GET /api/kis/status
 */
router.get('/status', kisController.getStatus)

/**
 * KIS API í† í° í…ŒìŠ¤íŠ¸
 * POST /api/kis/token/test
 */
router.post('/token/test', 
  authenticate,
  validateKisCredentials,
  kisController.testToken
)

/**
 * ì£¼ì‹ ê°€ê²© ì¡°íšŒ
 * GET /api/kis/stock/:symbol/price
 */
router.get('/stock/:symbol/price', 
  authenticate,
  kisController.getStockPrice
)

module.exports = router
```

#### 2. ì»¨íŠ¸ë¡¤ëŸ¬ íŒ¨í„´
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ëª…í™•í•œ ì»¨íŠ¸ë¡¤ëŸ¬
// controllers/kisController.js
const kisService = require('../services/kisService')
const { AppError } = require('../utils/errorHandler')
const { validateSymbol } = require('../utils/validators')

/**
 * KIS API ìƒíƒœ ì¡°íšŒ
 */
exports.getStatus = async (req, res, next) => {
  try {
    const status = await kisService.getApiStatus()
    
    res.json({
      success: true,
      data: status,
      timestamp: new Date().toISOString()
    })
  } catch (error) {
    next(error)
  }
}

/**
 * í† í° í…ŒìŠ¤íŠ¸
 */
exports.testToken = async (req, res, next) => {
  try {
    const { appKey, appSecret, mockMode } = req.body
    
    if (!appKey || !appSecret) {
      throw new AppError('APP KEYì™€ APP SECRETì´ í•„ìš”í•©ë‹ˆë‹¤.', 400, 'MISSING_CREDENTIALS')
    }
    
    const tokenResult = await kisService.testToken(appKey, appSecret, mockMode)
    
    res.json({
      success: true,
      data: tokenResult,
      message: 'í† í° í…ŒìŠ¤íŠ¸ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.'
    })
  } catch (error) {
    next(error)
  }
}

/**
 * ì£¼ì‹ ê°€ê²© ì¡°íšŒ
 */
exports.getStockPrice = async (req, res, next) => {
  try {
    const { symbol } = req.params
    const { mock = true } = req.query
    
    if (!validateSymbol(symbol)) {
      throw new AppError('ìœ íš¨í•˜ì§€ ì•Šì€ ì£¼ì‹ ì‹¬ë³¼ì…ë‹ˆë‹¤.', 400, 'INVALID_SYMBOL')
    }
    
    const priceData = await kisService.getStockPrice(symbol, mock === 'true')
    
    res.json({
      success: true,
      data: priceData,
      symbol: symbol,
      timestamp: new Date().toISOString()
    })
  } catch (error) {
    next(error)
  }
}
```

#### 3. ì„œë¹„ìŠ¤ ë ˆì´ì–´
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë¶„ë¦¬
// services/kisService.js
const { KISApiClient } = require('../utils/kisApiClient')
const { AppError } = require('../utils/errorHandler')
const cache = require('../utils/cache')

class KISService {
  constructor() {
    this.clients = new Map() // í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ìºì‹±
  }
  
  /**
   * KIS API í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
   */
  getClient(appKey, appSecret, mockMode = true) {
    const clientKey = `${appKey}_${mockMode}`
    
    if (!this.clients.has(clientKey)) {
      const client = new KISApiClient(appKey, appSecret, mockMode)
      this.clients.set(clientKey, client)
    }
    
    return this.clients.get(clientKey)
  }
  
  /**
   * API ìƒíƒœ í™•ì¸
   */
  async getApiStatus() {
    try {
      // ëª¨ì˜íˆ¬ì API ìƒíƒœ í™•ì¸
      const mockStatus = await this.checkApiEndpoint('mock')
      
      // ì‹¤ì „íˆ¬ì API ìƒíƒœ í™•ì¸ (ì„ íƒì )
      const realStatus = await this.checkApiEndpoint('real')
      
      return {
        mock: mockStatus,
        real: realStatus,
        lastChecked: new Date().toISOString()
      }
    } catch (error) {
      throw new AppError('API ìƒíƒœ í™•ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 500, 'API_STATUS_ERROR')
    }
  }
  
  /**
   * í† í° í…ŒìŠ¤íŠ¸
   */
  async testToken(appKey, appSecret, mockMode = true) {
    try {
      const client = this.getClient(appKey, appSecret, mockMode)
      const tokenData = await client.getAccessToken()
      
      return {
        hasToken: !!tokenData.access_token,
        tokenLength: tokenData.access_token?.length || 0,
        expiresIn: tokenData.expires_in,
        tokenType: tokenData.token_type,
        mockMode: mockMode
      }
    } catch (error) {
      throw new AppError(`í† í° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.message}`, 400, 'TOKEN_TEST_FAILED')
    }
  }
  
  /**
   * ì£¼ì‹ ê°€ê²© ì¡°íšŒ
   */
  async getStockPrice(symbol, mockMode = true) {
    try {
      // ìºì‹œ í™•ì¸ (1ë¶„ ìºì‹±)
      const cacheKey = `stock_price_${symbol}_${mockMode}`
      const cachedPrice = await cache.get(cacheKey)
      
      if (cachedPrice) {
        return JSON.parse(cachedPrice)
      }
      
      // API í˜¸ì¶œ
      const client = this.getClient(process.env.KIS_APP_KEY, process.env.KIS_APP_SECRET, mockMode)
      const priceData = await client.getStockPrice(symbol)
      
      // ìºì‹œ ì €ì¥
      await cache.setex(cacheKey, 60, JSON.stringify(priceData))
      
      return priceData
    } catch (error) {
      throw new AppError(`ì£¼ì‹ ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`, 400, 'STOCK_PRICE_ERROR')
    }
  }
  
  /**
   * API ì—”ë“œí¬ì¸íŠ¸ ìƒíƒœ í™•ì¸
   */
  async checkApiEndpoint(type) {
    try {
      const baseUrl = type === 'mock' 
        ? 'https://openapivts.koreainvestment.com:29443'
        : 'https://openapi.koreainvestment.com:9443'
      
      const response = await fetch(`${baseUrl}/ping`, { 
        method: 'GET',
        timeout: 5000 
      })
      
      return {
        available: response.ok,
        responseTime: response.headers.get('x-response-time') || 'unknown',
        status: response.status
      }
    } catch (error) {
      return {
        available: false,
        error: error.message,
        status: 0
      }
    }
  }
}

module.exports = new KISService()
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‘ì„± ê°€ì´ë“œ

### ğŸ“ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - ëª…í™•í•œ í…ŒìŠ¤íŠ¸ êµ¬ì¡°
// tests/services/kisService.test.js
const KISService = require('../../services/kisService')
const { KISApiClient } = require('../../utils/kisApiClient')
const { AppError } = require('../../utils/errorHandler')

// ëª¨í‚¹
jest.mock('../../utils/kisApiClient')
jest.mock('../../utils/cache')

describe('KISService', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })
  
  describe('testToken', () => {
    it('ìœ íš¨í•œ ìê²©ì¦ëª…ìœ¼ë¡œ í† í° í…ŒìŠ¤íŠ¸ ì„±ê³µ', async () => {
      // Arrange
      const mockTokenData = {
        access_token: 'test-access-token-123',
        expires_in: 86400,
        token_type: 'Bearer'
      }
      
      KISApiClient.prototype.getAccessToken.mockResolvedValue(mockTokenData)
      
      // Act
      const result = await KISService.testToken('test-app-key', 'test-app-secret', true)
      
      // Assert
      expect(result).toEqual({
        hasToken: true,
        tokenLength: 21,
        expiresIn: 86400,
        tokenType: 'Bearer',
        mockMode: true
      })
      
      expect(KISApiClient).toHaveBeenCalledWith('test-app-key', 'test-app-secret', true)
    })
    
    it('ì˜ëª»ëœ ìê²©ì¦ëª…ìœ¼ë¡œ í† í° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨', async () => {
      // Arrange
      KISApiClient.prototype.getAccessToken.mockRejectedValue(
        new Error('Invalid credentials')
      )
      
      // Act & Assert
      await expect(
        KISService.testToken('invalid-key', 'invalid-secret', true)
      ).rejects.toThrow(AppError)
      
      await expect(
        KISService.testToken('invalid-key', 'invalid-secret', true)
      ).rejects.toThrow('í† í° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: Invalid credentials')
    })
  })
  
  describe('getStockPrice', () => {
    it('ìºì‹œëœ ì£¼ì‹ ê°€ê²© ë°˜í™˜', async () => {
      // Arrange
      const cachedPrice = { price: 75000, symbol: '005930' }
      const cache = require('../../utils/cache')
      cache.get.mockResolvedValue(JSON.stringify(cachedPrice))
      
      // Act
      const result = await KISService.getStockPrice('005930', true)
      
      // Assert
      expect(result).toEqual(cachedPrice)
      expect(cache.get).toHaveBeenCalledWith('stock_price_005930_true')
      expect(KISApiClient.prototype.getStockPrice).not.toHaveBeenCalled()
    })
  })
})
```

### ğŸ”„ í†µí•© í…ŒìŠ¤íŠ¸
```javascript
// âœ… ì¢‹ì€ ì˜ˆì‹œ - API í†µí•© í…ŒìŠ¤íŠ¸
// tests/integration/kis.test.js
const request = require('supertest')
const app = require('../../server')

describe('KIS API Integration Tests', () => {
  describe('GET /api/kis/status', () => {
    it('API ìƒíƒœë¥¼ ì„±ê³µì ìœ¼ë¡œ ë°˜í™˜', async () => {
      const response = await request(app)
        .get('/api/kis/status')
        .expect(200)
      
      expect(response.body).toMatchObject({
        success: true,
        data: {
          mock: expect.objectContaining({
            available: expect.any(Boolean)
          }),
          real: expect.objectContaining({
            available: expect.any(Boolean)
          }),
          lastChecked: expect.any(String)
        },
        timestamp: expect.any(String)
      })
    })
  })
  
  describe('POST /api/kis/token/test', () => {
    it('ìœ íš¨í•œ í† í°ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ì„±ê³µ', async () => {
      const response = await request(app)
        .post('/api/kis/token/test')
        .send({
          appKey: process.env.TEST_APP_KEY,
          appSecret: process.env.TEST_APP_SECRET,
          mockMode: true
        })
        .expect(200)
      
      expect(response.body).toMatchObject({
        success: true,
        data: {
          hasToken: true,
          tokenLength: expect.any(Number),
          mockMode: true
        },
        message: expect.any(String)
      })
    })
    
    it('ëˆ„ë½ëœ ìê²©ì¦ëª…ìœ¼ë¡œ 400 ì—ëŸ¬ ë°˜í™˜', async () => {
      const response = await request(app)
        .post('/api/kis/token/test')
        .send({
          appKey: 'test-key'
          // appSecret ëˆ„ë½
        })
        .expect(400)
      
      expect(response.body).toMatchObject({
        success: false,
        error: 'APP KEYì™€ APP SECRETì´ í•„ìš”í•©ë‹ˆë‹¤.',
        code: 'MISSING_CREDENTIALS'
      })
    })
  })
})
```

## ğŸ“Š ì½”ë“œ í’ˆì§ˆ ë„êµ¬

### ğŸ” ì •ì  ë¶„ì„ ë„êµ¬

#### ESLint ì„¤ì •
```json
// .eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "@typescript-eslint/recommended",
    "react-hooks/recommended"
  ],
  "rules": {
    "no-console": "warn",
    "no-unused-vars": "error",
    "prefer-const": "error",
    "no-var": "error",
    "complexity": ["error", 10],
    "max-lines": ["error", 500],
    "max-lines-per-function": ["error", 50],
    "max-params": ["error", 4],
    "no-magic-numbers": ["warn", { "ignore": [0, 1, -1] }]
  }
}
```

#### Prettier ì„¤ì •
```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
```

### ğŸ“ˆ ì½”ë“œ ì»¤ë²„ë¦¬ì§€
```json
// jest.config.js
module.exports = {
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.test.{js,jsx,ts,tsx}',
    '!src/index.js'
  ]
}
```

## ğŸ“‹ ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

### âœ… ì¼ë°˜ ì‚¬í•­
- [ ] ì½”ë“œê°€ ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ëŠ”ê°€?
- [ ] ë„¤ì´ë°ì´ ëª…í™•í•˜ê³  ì¼ê´€ì„±ì´ ìˆëŠ”ê°€?
- [ ] í•¨ìˆ˜/í´ë˜ìŠ¤ê°€ ë‹¨ì¼ ì±…ì„ì„ ê°€ì§€ëŠ”ê°€?
- [ ] ì¤‘ë³µ ì½”ë“œê°€ ì—†ëŠ”ê°€?
- [ ] ì—ëŸ¬ ì²˜ë¦¬ê°€ ì ì ˆí•œê°€?

### âœ… ì„±ëŠ¥
- [ ] ë¶ˆí•„ìš”í•œ ë Œë”ë§ì´ ì—†ëŠ”ê°€?
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥ì„±ì´ ì—†ëŠ”ê°€?
- [ ] ë¹„ë™ê¸° ì²˜ë¦¬ê°€ ì ì ˆí•œê°€?
- [ ] ìºì‹±ì´ í•„ìš”í•œ ë¶€ë¶„ì— ì ìš©ë˜ì—ˆëŠ”ê°€?

### âœ… ë³´ì•ˆ
- [ ] ì…ë ¥ ê²€ì¦ì´ ì¶©ë¶„í•œê°€?
- [ ] ë¯¼ê°í•œ ì •ë³´ê°€ ë…¸ì¶œë˜ì§€ ì•ŠëŠ”ê°€?
- [ ] SQL ì¸ì ì…˜ ë“± ë³´ì•ˆ ì·¨ì•½ì ì´ ì—†ëŠ”ê°€?
- [ ] ì¸ì¦/ê¶Œí•œ ê²€ì‚¬ê°€ ì ì ˆí•œê°€?

### âœ… í…ŒìŠ¤íŠ¸
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ê°€ ì¶©ë¶„í•œê°€?
- [ ] ì—£ì§€ ì¼€ì´ìŠ¤ê°€ ê³ ë ¤ë˜ì—ˆëŠ”ê°€?
- [ ] í…ŒìŠ¤íŠ¸ê°€ ë…ë¦½ì ì´ê³  ë°˜ë³µ ê°€ëŠ¥í•œê°€?

## ğŸ“š ì°¸ê³  ìë£Œ

### ğŸ“– ìŠ¤íƒ€ì¼ ê°€ì´ë“œ
- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)
- [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)
- [React Best Practices](https://react.dev/learn/thinking-in-react)

### ğŸ› ï¸ ë„êµ¬
- [ESLint](https://eslint.org/)
- [Prettier](https://prettier.io/)
- [SonarQube](https://www.sonarqube.org/)
- [Jest](https://jestjs.io/)

## ğŸ“ ì—…ë°ì´íŠ¸ ì´ë ¥
- 2024-12-25: ì´ˆê¸° ì½”ë“œ í’ˆì§ˆ ê°€ì´ë“œë¼ì¸ ìƒì„±
- í–¥í›„ ì—…ë°ì´íŠ¸ ì˜ˆì •

---
**âš ï¸ ì¤‘ìš”**: ì´ ê°€ì´ë“œë¼ì¸ì€ íŒ€ ì „ì²´ê°€ í•©ì˜í•œ í‘œì¤€ì´ë©°, ëª¨ë“  ì½”ë“œëŠ” ì´ ê¸°ì¤€ì— ë”°ë¼ ì‘ì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. 